---
title: "Nuke – wygodne CI/CD programu końcowego w C#"
date: 2022-06-12
draft: false
image: cover.jpg
description: "Nuke pozwala nam na proste opisanie procesu budowania i publikowania naszej aplikacji w języku C#. Niniejszy artykuł nie skończy się na samym wprowadzeniu. Zamierzam pokazać Ci jak zbudować aplikację, uruchomić testy jednostkowe, wymusić odpowiednie pokrycie kodu oraz jak przygotować aplikację do publikacji. 
Opiszę również sposób przygotowania CI/CD dla Github Actions z uwzględnieniem parametrów pobierania sekretów repozytorium."

categories: 
    - "W okół kodu"
    - "CI/CD"
tags:
    - ".Net"
    - "CI/CD"
    - "Testy jednostkowe"
    - "Github Actions"
---
:toc: 
:experimental: true

== Wstęp
Wyobraź sobie, że całe CI/CD swojej aplikacji możesz opisać za pomocą C#.
Bez potrzeby nauki środowiska graficznego TeamCity, czy YAML'i GitHuba. 

Nuke jest jednym ze sposobów opisu budowania naszej aplikacji w języku C#. 
Jeżeli chcemy, aby nasz projekt był cały czas łatwo zarządzalny, musimy mieć sposób na opis wszystkich wymagań stawianych przed nim. 
I tak oto, możemy opisać:

1. (Czyszczenie) jak powinny wyglądać katalogi przed rozpoczęciem budowania projektu,
2. (Przygotowanie) jakich zależności potrzebuje nasza aplikacja do kompilacji,
3. (Budowanie) w jakiej kolejności budować poszczególne elementy,
4. (Testowanie) jak uruchamiać testy jednostkowe i jakie są nasze wymagania co do pokrycia nimi naszego kodu,
5. (Publikacja) jak spakować naszą aplikację i wysłać ją na środowisko produkcyjne. 

Nie jest to kompletna lista, tego, co możemy zrobić w trakcie procesu ciągłej integracji i dostarczania. 
Na pewno pokazuje ona podstawowe zagadnienia, przed którymi jesteśmy stawiani podczas wydawania kolejnej wersji naszego oprogramowania. 
I jak to w życiu bywa, jeśli czegoś nie zapiszemy, to pewno o tym zapomnimy.
A po co zapisywać coś na skrawku papieru, gdy można to zrobić za pomocą kodu, który wykona się sam? 

Wszystkie wyżej opisane kroki możemy opisywać w różnych językach.
Robimy to często w tak wyspecjalizowanych formach, jak projekty budujące na TeamCity, czy GitHub Actions. 
Nuke przekonał mnie tym, że nie muszę uczyć się tych wszystkich konfiguracji osobno – mogę opisać wszystko, co niezbędne za pomocą dobrze mi znanego języka C# i wykorzystywać tam, gdzie potrzebuję.
W przypadku GitHub Actions mogę bez problemu również wykorzystać raz napisany kod w wielu różnych przepływach, co stanowczo upraszcza pracę i testowanie.

== Wstępna konfiguracja z pomocą kreatora

Wstępną konfigurację naszego projektu warto zacząć od instalacji narzędzia Nuke, które stanowczo ułatwia pracę dewelopera.
Co ważne, nie jest ono niezbędne na serwerze budującym.

[source,powershell]
----
dotnet tool install Nuke.GlobalTool --global
----

Konfigurator Nuke pozwala nam bardzo sprawnie rozpocząć pracę.
Przygotowuje on w zasadzie cały powtarzalny kod, który jest niezbędny do tego, aby rozpocząć z nim zabawę.

=== Plugin do Visual Studio 2022

Plugin do Visual Studio pozwala nam na wywoływanie akcji budowania prosto z IDE. 
Do tego dochodzi możliwość debugowania.

NOTE: Często, aby zmiany w kodzie budującym zostały zastosowane, niezbędne jest przebudowanie projektu. 
Samo budowanie, bez czyszczenia, rzadko daje efekty.

// Wyjaśnienie poszczególnych elementów raczej wolałbym dać w ramkach w tekście
.DependsOn()
****
`DependsOn` pozwala nam na określenie, jakie kroki trzeba wykonać przed wykonaniem wybranej akcji.
****

.Requires()
****
`Requires` pozwala określić nam, wymagania niezbędne do uruchomienia danej akcji. 
Jeśli, któryś z warunków nie będzie spełniony, zostanie wyświetlony błąd a cała procedura przerwana.
****

.Atrybut [Parameter]
****
Atrybut `Parameter` pozwala nam jasno określić parametry konfiguracyjne naszego procesu budującego. 
Daje on nam możliwość ustawienia opisu, wartości domyślnej.
Co ważne, wartości oznaczone atrybutem `Parameter` mogą być pozyskane zarówno z wiersza poleceń, przy uruchomieniu programu budującego, jak i ze zmiennych środowiskowyhc.
****

.Secret()
****
Oznaczenie parametru jako `Secret` spowoduje, że jego wartość nie zostanie wyświetlona w trakcie precesu budującego.
****

.CombineWith()
****
`CombineWith` pozwala nam na proste tworzenie kombinacji budowania. 
Kopiuje on konfigurację i pozwala na zmianę poszczególnych parametrów na podstawie dostarczonej kolekcji.
****

== Testy jednostkowe

Testy jednostkowe są niezbędnym elementem, jeśli chcemy utrzymać wysoką jakość naszego projektu oraz łatwość jego rozwoju w dłuższym czasie. 

== Pokrycie testami jednostkowymi

Pokrycie testami jednostkowymi jest badane za pomocą `Coverlet`, które jest domyślnie używane przez środowisko `dotnet test`.
Jednak jego poprawne użycie zajęło mi na prawdę sporo czasu. 
Aby móc z niego skorzystać musisz zainstalować odpowiednia paczkę:

[source,powershell]
----
nuke :add-package coverlet.console --version 3.1.2
# lub, jeśli nie zainstalowałeś narzędzia nuke
dotnet tool install --global coverlet.console --version 3.1.2
----

Największym problemem, okazało się wymuszenie odpowiedniego pokrycia testami.
Tylko jedna, z wielu testowanych przeze mnie konfiguracji, działa, to jest, zwraca błąd, gdy pokrycie testami jest niższe niż wskazane.

Nie użyłem DotCover, ponieważ nie jestem pewien, czy mogę go wykrzystywać w każdym projekcie.

WARNING: Działa tylko na Windows.

== Raport z testów jednostkowych

Raport ułatwi nam śledzenie, które moduły naszej aplikacji są testowane w najwyższym stopniu, a które w najniższym.
Istnieją także platformy, które potafią zrobić z nich większy użytek

== Publikowanie z wysyłką do Netlify jako przykład CI/CD.

Jako przykład pełnego CI/CD pokażę publikowanie projektu blazorowego do usługi Netlify, dzięki czemu, aplikacja Web Assembly będzie dostępna w Internecie.

Przykłady publikowania paczek nuget są łatwo dostępne w Internecie #TODO: Dodać przykładowy link!#, a moje podejście do sprawy pokażę w następnej części tej serii artykułów.

== Github Actions

Wszelką konfigurację github action robimy za pomocą atrybutu.

=== Dla pull requestów

NOTE: Nie zapomnij dodać definicji parametrów pobieranych z sekretów do pliku YAML. 

=== Dla CI/CD.

Proces budowania dla CI/CD chcemy, aby był uruchamiany tylko po poprawnym połączeniu z gałęzią master. 

== Opis dodatkowy
`build.ps1 --help`
`build.ps1 --plan`


=== Budowanie równoległe niektórych kroków
=== Logowanie Serilog.Warning()
=== Łączenie ścieżek do pliku za pomocą operatora /

Photo by https://unsplash.com/es/@burgessbadass?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText[Burgess Milner] on https://unsplash.com/s/photos/nuke?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText[Unsplash].

== Podsumowanie

=== Minusy
Słaba dokumentacja. 
Szukanie zawsze trzeba wykonywać w dwóch kierunkach: 1) jak to powinno być zrobione natywnie za pomocą danego narzędzia, 2) jak to zrobic w Nuke. 
Mogłoby być zdecydowanie więcej przykładów.

== Część druga


=== Automatyczne numerowanie: GitVersion

// Z tym mam problem, no bo nie ogarnąłem tak na prawdę tematu i muszę zrobić to osobno

https://blog.dangl.me/archive/escalating-automation-the-nuclear-option/


=== Przygotowywanie i publikacji paczki Nuget
https://github.com/zarunbal/LogExpert/blob/master/build/Build.cs
https://github.com/fluentassertions/fluentassertions/blob/master/Build/Build.cs

----
    Target Push => _ => _
        .DependsOn(Pack)
        .OnlyWhenDynamic(() => IsTag)
        .Executes(() =>
        {
            IReadOnlyCollection<string> packages = GlobFiles(ArtifactsDirectory, "*.nupkg");

            Assert.NotEmpty(packages.ToList());

            DotNetNuGetPush(s => s
                .SetApiKey(ApiKey)
                .EnableSkipDuplicate()
                .SetSource("https://api.nuget.org/v3/index.json")
                .EnableNoSymbols()
                .CombineWith(packages,
                    (v, path) => v.SetTargetPath(path)));
        });
----


=== Changelog z GitHub (i nie tylko...??)
https://github.com/nuke-build/nuke/blob/develop/build/Build.GitFlow.cs

https://blog.dangl.me/archive/escalating-automation-the-nuclear-option/
Nuke.Github.GetCompleteChangeLog()

=== Nowe wydanie na GitHubie 

https://github.com/zarunbal/LogExpert/blob/master/build/Build.cs
https://blog.dangl.me/archive/escalating-automation-the-nuclear-option/
https://www.ariank.dev/create-a-github-release-with-nuke-build-automation-tool/ (tu jest tylko wycinek)

[source,csharp]
----
GitHubTasks.GitHubClient = new GitHubClient(new ProductHeaderValue(nameof(NukeBuild)))
{
  Credentials = new Credentials(GithubRepositoryAuthToken)
};
var newRelease = new NewRelease(BuildInfo.TagName)
{
  TargetCommitish = CommitSha,
  Draft = true,
  Name = $"Release version {BuildInfo.SemanticVersion}",
  Prerelease = BuildInfo.SemanticVersion.IsPrerelease,
  Body =
    @$"See release notes in [docs](https://[YourSite]/{BuildInfo.SemanticVersion.Major}.{BuildInfo.nticVersion.Minor}/)"
};

var createdRelease = GitHubTasks.GitHubClient.Repository.Release.Create(RepositoryId, newRelease).Result;
----

== Część tzecia, będzie bardziej tematyczna

=== Dodawanie sonar qube 
To będzie wymagało trochę więcej pracy, bo jeszcze trzeba ogarnąć samego Sonara i wdrożenie go do projektu. 
Bo jak wdrażać Sonar, to tak, aby traktować ostrzeżenia jako błędy. 
https://github.com/ChilliCream/hotchocolate/blob/main/.build/Build.Sonar.cs


=== Budowanie obrazu dockera 
https://github.com/avivasolutionsnl/sitecore-docker/tree/master/build

.Unlisted
****
#TODO: Nie mam pojęcia na ten moment#
****

.=== OnlyWhenStatic
****
#TODO: Nie mam pojęcia na ten moment#
****
