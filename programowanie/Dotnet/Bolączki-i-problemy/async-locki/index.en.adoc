---
title: "Async, locks and monitors – where is the problem?"
date: 2021-08-24T15:52:17Z
draft: true
image: cover.jpg
description: "In this article, I present an interesting pitfall that awaits the .Net programmer in the case where they need to secure access to code, and that code would like to execute asynchronously..."
categories: 
    - ".Net"
    - "Pułapki na programistę"
    - "Wielowątkwość"
tags:
    - "C-sharp"
    - "async"
    - "await"
---

= Async, locks and monitors – where is the problem?
:source-highlighter: pygments
:icons: font
:toc:

In this article, I will not cover the basics on how to write multithreaded code.
It is addressed to people who have an idea how to start tasks in separate processes. 
However, I don't require any special knowledge here, so even beginners should find something for themselves.
If, on the other hand, you're looking for something that would give you useful basics, I encourage you to visit: https://markheath.net/post/constraining-concurrent-threads-csharp[here], https://markheath.net/post/async-antipatterns[here] and the blog https://blog.stephencleary.com/[Stephen Cleary].

For the record, all the following examples are run with a piece of code like this:

[source,csharp]
----
include::src/Executor.cs[]
----

where `noOfTasks` tells you how many tasks to run in parallel, while `test` is a function for testing.
For each test, the object is created from scratch.

== How to do it wrong

=== lock()

Let's start from the beginning. 
Normally the compiler won't allow us to call asynchronous code (requiring `await`) inside a `lock(...) {...}` structure - it will return a laconic `error CS1996: Cannot await in the body of a lock statement`.
Such non-functioning code can be seen below:

[source,csharp]
.The compiler will not allow us to build code where we have the await keyword inside the lock.
----
private object _locker = new object();
async Task NotWorkingLock() 
{
    lock(_locker) {
        await Task.Delay(TimeSpan.FromSeconds(5));
    }
}
----

=== Monitor

WARNING: The code in this section is incorrect and can cause hard-to-find errors, even if it doesn't look like it!

Unfortunately, concurrent programming in C# is viral, meaning that once `async` and `await` are added they spread further into our software, which can lead us to a situation where we necessarily want to control the execution of a certain asynchronous method. 
It's possible that at such a point it will occur to us to write something like this:

Translated with www.DeepL.com/Translator (free version)

[source,csharp]
.Pozorna kontrola wywołania funkcji asynchronicznej
----
include::src/MonitorExample.cs[]
----

<1> Odkomentowanie tej linijki daje jeszcze bardziej kosmiczne wyniki jak na przykład wielokrotne wchodzenie do sekcji krytycznej...

W momencie, gdy go uruchomimy, zobaczymy taki wynik jak poniżej.
Wygląda on dobrze... 

[source]
.Wynik pracy dwóch zadań
----
With lock (1-5)!
Without lock (2-4)!
Exiting... (2-4)
Exiting... (1-5)
----

Co się jednak stanie, gdy ilość wątków z 2 zmienimy na większą niż mamy wątków fizycznych procesora? 
Otóż pojawiają się poważny problem, gdyż w trakcie działania programu otrzymujemy wyjątek:

`System.Threading.SynchronizationLockException : Object synchronization method was called from an unsynchronized block of code.`

Co gorsza, nie pojawia się on zawsze, co niektóre uruchomienia powyższego kodu kończą się na moim komputerze poprawnie. 
W bardziej skomplikowanych przykładach może zdążyć się nawet wielokrotne wejście do sekcji krytycznej – aby to zaobserwować odkomentuj linijkę, na której końcu znajduje się cyfra (1).
Wynik, jaki możesz zaobserwować to, na przykład: 

[source]
.Wynik pracy dziesięciu zadań
----
Without lock (4-6)!
Without lock (2-5)!
Without lock (3-11)!
Without lock (7-10)!
Without lock (8-4)!
Without lock (1-7)!
With lock (5-9)! <1>
Without lock (6-8)!
Without lock (10-4)!
With lock (9-9)! <2>
Exiting... (6-8)
Exiting... (7-10)
Exiting... (2-5)
Exiting... (3-11)
Exiting... (8-4)
Exiting... (4-6)
Exiting... (10-4)
Exiting... (1-7)
----

Zwróć uwagę, że (1) i (2) pokazują, że program wszedł do sekcji krytycznej dwa razy!
Dodatkowo, taki scenariusz może pozostać niewykryty, dopóki ilość zadań uruchamianych asynchronicznie nie przekracza pewnej magicznej liczby w systemie, co może powodować trudne do wykrycia błędy!

=== Trochę wyjaśnienia

Wyjątki są powodowane tym problemem, że obiekt `locker` jest zwalniany przez inny wątek niż ten, który go zablokował.
Dzieje się tak, gdyż mechanika `async-await` nie gwarantuje kontynuowania na tym samym wątku. 
Pisze o tym również Eric Lippert (który podaje w swoim profilu na SO, że pracował nad kompilatorem C#), co można przeczytać pod tym adresem: https://stackoverflow.com/a/7612714/6208972.

Jako ciekawostkę chciałbym wskazać, że na poprzednim wyniku programu, miejsca wskazane przez (1) i (2) mają ten sam identyfikator wątku, ale inny zadania! 
Może to sugerować, że mechanizm monitora oparty jest właśnie na identyfikatorze tego pierwszego. 

== Jak to zrobić dobrze

Całe szczęście rozwiązanie problemu asynchroniczności i ochrony sekcji krytycznej nie jest skazane na porażkę, mamy na to kilka sposobów.

=== Nie wywołuj kodu asynchronicznego w sekcji krytycznej

Może wydawać się to dziwne, że takie rozwiązanie polecam jako pierwsze, ale przez cały czas mojej edukacji kładziono mi do głowy, że sekcja krytyczna powinna być możliwe najkrótsza i najprostsza. 
Wiąże się to z tym, że im mniej synchronizacji wątków wymagamy, tym szybszy będzie nasz kod! 
Także, zanim sięgniesz po kolejne rozwiązania, rozważ, czy aby na pewno nie przesadzasz z zadaniami wykonywanymi w sekcji krytycznej.

=== Sekcja krytyczna tylko dla flagi

Sposób ten może nie jest najpiękniejszy, ale na pewno jest łatwo dostępny, gdyż nie wymaga ani nowej wersji .Neta ani zewnętrznych bibliotek, tak więc:

[source,csharp]
.Brzydka, acz w miarę bezpieczna kontrola wywołania asynchronicznej sekcji krytycznej
----
include::src/CriticalSectionForFlag.cs[]
----

<1> Nawet z takim paskudztwem implementacja działa tak, jak powinna.

Wady tej implementacji to na pewno złożoność: przekopiowywanie jej wewnątrz projektu może prowadzić do mnóstwa zdublowanych linijek kodu (czego nie lubimy), a ilość kodu niezbędna do działania powoduje, że łatwo w tym wszystkim zrobić błąd. 
W związku z tym przejdźmy do czegoś, co znajduje się już w nowszych frameworkach (w sumie dostępna już od 2013 roku, jak nie wcześniej :D):

[sidebar]
.Problem z ThreadAbortException
****
Jeśli zastanawiasz się, dlaczego powyżej napisałem "w miarę bezpieczna" to śpieszę z wyjaśnieniem.
Otóż jest taki problem, że w dowolnym momencie wykonania powyższej funkcji może dojść do wywołania wyjątku `ThreadAbortException`, który może przerwać jej wykonywanie i zostawić w dziwnym stanie co w konsekwencji może doprowadzić nas do deadlocka.
Całe szczęście jest to coraz mniej prawdopodobne, gdyż używanie `Thread.Abort` zostało uznane za złą praktykę, a w jego miejsce wprowadzono `CancellationToken`. 
Jeśli chcesz poczytać szczegółowe rozważania, jak zabezpieczyć się w takim przypadku zapraszam do odpowiedzi na pytanie na stacku: https://stackoverflow.com/a/61806749/6208972.
****

=== SemaphoreSlim.WaitAsync

Pewnego dnia, ktoś, kto odpowiada za .Neta w końcu poszedł po rozum do głowy i stanowczo uprościł kwestię asynchroniczności i sekcji krytycznej

[source,csharp]
----
include::src/AsyncSemaphore.cs[]
----

Przykład ten jest dużo prostszy, gdyż sam w sobie na to pozwala.
W przypadku uruchomienia tego programu otrzymujemy jasny i klarowny wynik:

[source]
----
Before trying lock (2-5)!
Before trying lock (1-4)!
With lock (2-5)!
Exiting... (2-5)
With lock (1-4)!
Exiting... (1-4)
----

Na plus na pewno jest zwięzłość takiego przykładu w najprostszej formie. 
Jednak gdyby chciał osiągnąć taki sam efekt jak w przypadku `Monitor.TryEnter()`, to całość rozrosłaby się podobnie jak w poprzednim przypadku.
Na minus muszę zwrócić Ci uwagę, że to rozwiązanie również może powodować problemy – w szczególności podczas pracy z wyjątkowo starym kodem (jeszcze sprzed .Net Framework 4).
Po więcej informacji zajrzyj powyżej do ramki z napisem "Problem z ThreadAbortException".

== Ostrożnie ze wzorcem if-lock-if

Na koniec chciałbym jeszcze wspomnieć o dość popularnym wzorcu blokady z podwójnym zatwierdzeniem. 
Już sama https://pl.wikipedia.org/wiki/Blokada_z_podw%C3%B3jnym_zatwierdzeniem_(wzorzec_projektowy)[wikipedia] mówi nam, że w niektórych przypadkach (między innymi w języku Java i C++), gdzie może dojść do trudnych do wykrycia problemów z wyścigiem wątków. 
Jeszcze więcej na ten temat można przeczytać http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html[tutaj (po angielsku]. 
Także lepiej omijać ten sposób z daleka.

== Podsumowanie

Programowanie współbieżne nie jest łatwe, a do tego pułapki czekają wszędzie. 
Nie zdziwię się, jeśli nawet i w tym artykule znajdzie się jakiś błąd, który wyjdzie w jakimś szczególnym przypadku. 
Jeśli coś takiego zauważyłeś, to proszę, daj znać w komentarzach! 

Wybór odpowiedniej metody synchronizacji zależy od tego, na jakim etapie prac jesteśmy. 
Jeśli dwie przytoczone powyżej, to za mało warto może jeszcze rozejrzeć się za bibliotekami pokroju https://github.com/StephenCleary/AsyncEx[AsyncEx], która rozwija możliwości pracy asynchronicznej (z tej przytoczonej tutaj jeszcze nie korzystałem, także nie wypowiem się, czy jest dobra).

Warto jednak zawsze mieć w głowie jedną z zasad Roberta C. Martina z książki https://helion.pl/ksiazki/czysty-kod-podrecznik-dobrego-programisty-robert-c-martin,czykov.htm["Czysty kod. Podręcznik dobrego programisty"], że zarządzenie dostępem do sekcji krytycznej jest jedną odpowiedzialnością a sama sekcja krytyczna osobną. 
Taki podział zadań pozwoli nam na skupienie się na jakości każdego z elementów. 