---
title: "Async, locks and monitors – where is the problem?"
date: 2021-08-24T15:52:17Z
draft: false
image: cover.jpg
description: "In this article, I present an interesting pitfall that awaits the .Net programmer in the case where they need to secure access to code, and that code would like to execute asynchronously..."
categories: 
    - ".Net"
    - "Pułapki na programistę"
    - "Wielowątkwość"
tags:
    - "C-sharp"
    - "async"
    - "await"
---

= Async, locks and monitors – where is the problem?
:source-highlighter: pygments
:icons: font
:toc:

In this article, I will not cover the basics on how to write multithreaded code.
It is addressed to people who have an idea how to start tasks in separate processes. 
However, I don't require any special knowledge here, so even beginners should find something for themselves.
If, on the other hand, you're looking for something that would give you useful basics, I encourage you to visit: https://markheath.net/post/constraining-concurrent-threads-csharp[here], https://markheath.net/post/async-antipatterns[here] and the blog https://blog.stephencleary.com/[Stephen Cleary].

For the record, all the following examples are run with a piece of code like this:

[source,csharp]
----
include::src/Executor.cs[]
----

where `noOfTasks` tells you how many tasks to run in parallel, while `test` is a function for testing.
For each test, the object is created from scratch.

== How to do it wrong

=== lock()

Let's start from the beginning. 
Normally the compiler won't allow us to call asynchronous code (requiring `await`) inside a `lock(...) {...}` structure - it will return a laconic `error CS1996: Cannot await in the body of a lock statement`.
Such non-functioning code can be seen below:

[source,csharp]
.The compiler will not allow us to build code where we have the await keyword inside the lock.
----
private object _locker = new object();
async Task NotWorkingLock() 
{
    lock(_locker) {
        await Task.Delay(TimeSpan.FromSeconds(5));
    }
}
----

=== Monitor

WARNING: The code in this section is incorrect and can cause hard-to-find errors, even if it doesn't look like it!

Unfortunately, concurrent programming in C# is viral, meaning that once `async` and `await` are added they spread further into our software, which can lead us to a situation where we necessarily want to control the execution of a certain asynchronous method. 
It's possible that at such a point it will occur to us to write something like this:

[source,csharp]
.Apparent control of an asynchronous function call
----
include::src/MonitorExample.cs[]
----

<1> Uncommenting this line gives even more cosmic results like entering the critical section multiple times...

When we run it, we will see a result like below.
It looks quite good... 

[source]
.The result of two concurrent tasks
----
With lock (1-5)!
Without lock (2-4)!
Exiting... (2-4)
Exiting... (1-5)
----

But what happens when we change the number of threads from 2 to more than we have physical threads of the processor? 
Well, a serious problem arises, because we get an exception while the program is running:

`System.Threading.SynchronizationLockException : Object synchronization method was called from an unsynchronized block of code.`

What's worse, it doesn't always appear, which some runs of the above code end up correctly on my machine. 
In more complicated examples, it may even happen to enter the critical section multiple times - to observe this, uncomment the line at the end of which there is a number (1).
The result you may observe is, for example: 

[source]
.Result of ten concurrent tasks
----
Without lock (4-6)!
Without lock (2-5)!
Without lock (3-11)!
Without lock (7-10)!
Without lock (8-4)!
Without lock (1-7)!
With lock (5-9)! <1>
Without lock (6-8)!
Without lock (10-4)!
With lock (9-9)! <2>
Exiting... (6-8)
Exiting... (7-10)
Exiting... (2-5)
Exiting... (3-11)
Exiting... (8-4)
Exiting... (4-6)
Exiting... (10-4)
Exiting... (1-7)
----

Note that (1) and (2) show that the program entered the critical section twice!
Moreover, such a scenario can go undetected until the number of tasks running asynchronously exceeds some magic number in the system, which can cause hard-to-detect mistakes!

=== A little explanation

Exceptions are caused by the problem that the `locker` object is released by a different thread than the one that locked it.
This is because the `async-await` mechanic does not guarantee continuation on the same thread. 
Eric Lippert (who states in his SO profile that he worked on the C# compiler) also writes about this, as you can read at this link: https://stackoverflow.com/a/7612714/6208972.

As a note of interest, I would like to point out that on the previous program result, the lines indicated by (1) and (2) have the same thread ID, but a different task! 
This may suggest that the monitor mechanism is based precisely on the identifier of the former. 

== How to do it right

#TODO: Translate the rest#