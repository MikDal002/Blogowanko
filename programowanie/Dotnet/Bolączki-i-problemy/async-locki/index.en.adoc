---
title: "Async, locks and monitors – where is the problem?"
date: 2021-08-24T15:52:17Z
draft: false
image: cover.jpg
description: "In this article, I present an interesting pitfall that awaits the .Net programmer in the case where they need to secure access to code, and that code would like to execute asynchronously..."
categories: 
    - ".Net"
    - "Pułapki na programistę"
    - "Wielowątkwość"
tags:
    - "C-sharp"
    - "async"
    - "await"
---

= Async, locks and monitors – where is the problem?
:source-highlighter: pygments
:icons: font
:toc:

In this article, I will not cover the basics on how to write multithreaded code.
It is addressed to people who have an idea how to start tasks in separate processes. 
However, I don't require any special knowledge here, so even beginners should find something for themselves.
If, on the other hand, you're looking for something that would give you useful basics, I encourage you to visit: https://markheath.net/post/constraining-concurrent-threads-csharp[here], https://markheath.net/post/async-antipatterns[here] and the blog https://blog.stephencleary.com/[Stephen Cleary].

For the record, all the following examples are run with a piece of code like this:

[source,csharp]
----
include::src/Executor.cs[]
----

where `noOfTasks` tells you how many tasks to run in parallel, while `test` is a function for testing.
For each test, the object is created from scratch.

== How to do it wrong

=== lock()

Let's start from the beginning. 
Normally the compiler won't allow us to call asynchronous code (requiring `await`) inside a `lock(...) {...}` structure - it will return a laconic `error CS1996: Cannot await in the body of a lock statement`.
Such non-functioning code can be seen below:

[source,csharp]
.The compiler will not allow us to build code where we have the await keyword inside the lock.
----
private object _locker = new object();
async Task NotWorkingLock() 
{
    lock(_locker) {
        await Task.Delay(TimeSpan.FromSeconds(5));
    }
}
----

=== Monitor

WARNING: The code in this section is incorrect and can cause hard-to-find errors, even if it doesn't look like it!

Unfortunately, concurrent programming in C# is viral, meaning that once `async` and `await` are added they spread further into our software, which can lead us to a situation where we necessarily want to control the execution of a certain asynchronous method. 
It's possible that at such a point it will occur to us to write something like this:


[source,csharp]
.Pozorna kontrola wywołania funkcji asynchronicznej
----
include::src/MonitorExample.cs[]
----
#TODO: Translate the rest!#