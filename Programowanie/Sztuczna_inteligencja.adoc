= Algorytmy Genetyczne
Mikołaj Dalecki <mikdal002@utp.edu.pl>; Mateusz Lewandowski <matlew13@utp.edu.pl>; Karol Appel <karapp002@utp.edu.pl>; Przemysław Nadobny <prznad005@utp.edu.pl>; Jacek Suty <jacsut000@utp.edu.pl>
:toc:
:imagesdir: ./img
:sectnums:
:iconsdir: ./icons
:sectanchors:
:source-highlighter: pygments
:keywords: asciidoc, wstęp
:doctype: book
:toc-title: Spis treści
:caution-caption: Ostrożnie
:important-caption: Ważne
:note-caption: Uwaga
:tip-caption: Podpowiedź
:warning-caption: Ostrzeżenie
:appendix-caption: Załącznik
:example-caption: Przykład
:figure-caption: Ilustracja
:table-caption: Tabela
:chapter-label: Rozdział

[.lead]
Niniejsze sprawozdanie jest rezultatem prac nad algorytmami genetycznymi i ich wykorzystaniem w znajdowaniu rozwiązania problemu komiwojażera/plecakowego i optymalizacji funkcji w porównaniu z algorytmem optymalizacji rojem cząstek (PSO). 

= Wstęp
indexterm:[John Holland]
((Algorytm genetyczny)) (dalej w pracy w skrócie AG) znajduje się w grupie algorytmów ewolucyjnych i jest powszechnie używany do problemów optymalizacyjnych, takich jak znajdowanie najkrótszej drogi, bądź modelowania systemów, gdzie zmienność odgrywa znaczącą rolę (np. giełda).
Jest on wyszukiwaniem heurystycznym zainspirowany zmianami genetycznymi w populacji i został przedstawiony przez Johna Hollanda na początku lat 70 XX wieku. 
Algorytm ten oparty jest o takie zagadnienia, jak: dziedziczenie, mutacje, selekcje i krzyżowania, które będą opisane w dalszej części pracy <<Kumar2010>>.

Uproszczony schemat działania algorytmu genetycznego przedstawiono na diagramie poniżej.
Pokrótce mówi on nam, aby <<Kumar2010>>:

. Zdefiniować nową populację poprzez wylosowanie całkowicie nowych osobników (przy rozpoczęciu algorytmu) bądź poprzez dokonanie wyboru rodziców, krzyżowania i mutacji.
. Następnie obliczyć dopasowanie każdego chromosomu.
. Na końcu sprawdzić, czy warunek zakończenia działania programu jest spełniony, jeśli nie, to powtórzyć. 

Wszystkie wymienione elementy zostaną szerzej opisane w następnych rozdziałach i sekcjach.

[plantuml, zasada-dzialania-ag, png]
.Sposób działania Algorytmu Genetycznego
....
start
repeat
    if (Czy to pierwsza generacja?) then (tak)
        :Wygeneruj zestaw losowych chromosomów;
    else (nie)
        :Wybierz rodziców;
        :Dokonaj krzyżowania;
        :Dokonaj ewentualnej mutacji;
    endif
    :Oblicz dopasowanie każdego chromosomu;
    
repeat while (Czy należy zakończyć algorytm?)
end
....


== Chromosomy
Każdy z chromosomów reprezentuje jedno możliwe rozwiązanie, a każdy z chromosomów składa się z ((allel))i (czasem zwanymi genami), które stanowią drobną część (na przykład bit, znak lub liczbę) będącą częścią tegoż rozwiązania  <<Kumar2010>>.

#TODO: TBD#

=== `GeneableChromosome` – implementacja
W naszym rozwiązaniu chromosom może implementować interfejs `IChromosome`, który przechowuje jedynie wartość dopasowania (`Fitness`). 
Jednak w celu uproszczenia implementacji, postępując zgodnie z zasadą DRY (z ang. _don't repeat yourself_ – nie powtarzaj siebie) wprowadzono interfejs `IGeneableChromosome`, który pozwala na dekompozycję każdego rozwiązania na drobne kawałki. 
Definicja tychże interfejsów prezentuje się następująco: 

#TODO: Dodać ilustrację chromosomu z różnymi genami#

[source,csharp]
.Interfejsy dla ((chromosom))ów
----
public interface IChromosome : IComparable
{
    double? Fitness { get; set; }
}
public interface IGenableChromosome<T> : IChromosome
{
    public IReadOnlyList<T> Genes { get; }
}
----
#TODO: TBD#

=== Funkcja dopasowania
Funkcja dopasowania jest inna dla każdego problemu i służy do oceny danego rozwiązania (chromosomu) footnote:[https://en.wikipedia.org/wiki/Fitness_function].
Najczęściej spotykanym traktowania dopasowania jest „im większe, tym lepsze”, aczkolwiek w naszym rozwiązaniu możliwe jest odwrócenie tej zasady, co pozwala na naturalne pisanie funkcji optymalizacyjnych.
Z takiej możliwości korzysta rozwiązanie problemu ((komiwojażer))a, gdzie wartość dopasowania jest równa długości ścieżki, jaką musi przebyć, a ta jest tym lepsza, im jest krótsza. 

Przykłady implementacji funkcji dopasowania zostaną przedstawione w następnych rozdziałach przy okazji omówienia poszczególnych problemów.

== Selekcja rodziców i populacja
W każdej następnej generacji dochodzi do selekcji rodziców w celu zrobienia potomków, którzy będą stanowili nową generację.
Rozmiar generacji zależy od natury problemu i zazwyczaj mieści się w zakresie od kilkuset do kilku tysięcy osobników.

Wybór rodziców zazwyczaj opiera się o poziom dopasowania do problemu: im lepszy, tym większe prawdopodobieństwo zostania dawcą genów  <<Kumar2010>>. 
#TODO: TBD#

=== Selekcja ruletkowa
indexterm:[Selekcja, Turniejowa]
Selekcja ruletkowa (oraz selekcja turniejowa – nieporuszana w niniejszej pracy) jest jedną z popularniejszych metod selekcji  <<Kumar2010>>. 
#TODO: TBD#

[source,csharp]
.Implementacja selekcji ruletkowej indexterm:[Selekcja, ruletkowa]
----
public class RouletteSelection
{
    private readonly Random _random = new();
    public bool? IsReversed { get; set; } = null;

    public IEnumerable<T> SelectChromosomes<T>(Generation<T> previousGeneration, int requiredNumberOfParents)
        where T : IChromosome
    {
        if (IsReversed == null) <1>
        {
            var min = previousGeneration.Min();
            var max = previousGeneration.Max();
            IsReversed = max.Fitness < min.Fitness;
        }

        var sumOfFitnesse = 0.0;

        foreach (var chrom in previousGeneration)
        {
            if (!chrom.Fitness.HasValue)
                throw new ArgumentException("Chromosome doesn't have fitness calculated!");

            sumOfFitnesse += chrom.Fitness.Value;
        }

        if (IsReversed == true) sumOfFitnesse = 1.0 / sumOfFitnesse;

        var parentThresholds = new List<double>(requiredNumberOfParents);

        for (int i = 0; i < requiredNumberOfParents; ++i)
            parentThresholds.Add(_random.NextDouble() * sumOfFitnesse);

        parentThresholds = parentThresholds.OrderBy(d => d).ToList(); <2>

        var minimumParentThreshold = parentThresholds[0];

        var selectionProgress = 0.0;
        foreach (var chrom in previousGeneration)
        {
            selectionProgress += IsReversed == true ? 1.0 / chrom.Fitness!.Value : chrom.Fitness!.Value; <3>
            if (minimumParentThreshold > selectionProgress) continue;

            parentThresholds.RemoveAt(0); <4>
            yield return chrom;

            if (parentThresholds.Count == 0) yield break;
            minimumParentThreshold = parentThresholds[0];
        }
    }
}
----

<1> Na początku należy sprawdzić, czy czasem chromosom nie ma odwróconego wartościowania (to znaczy, że lepsza odpowiedź to ta o mniejszej wartości).
<2> Następnie losujemy tyle progów ile rodziców potrzeba (domyślnie 2) wyrażonych w procentach.
<3> Na końcu w bierzemy kolejne chromosomy i dodajemy ich wartości do siebie. W momencie, w którym suma przekroczy procentową wartość progu, aktywny chromosom zostaje wybrany na rodzica.
<4> Algorytm jest powtarzany, aż wszystkie progi zostaną przekroczone.

== Krzyżowanie
Krzyżowanie, czasem zwane również ((rekomobinowanie))m, to proces łączenia genów rodziców w taki sposób, aby uzyskać nowego potomka, reprezentujące nowe rozwiązanie <<Kumar2010>>. 

=== Krzyżowanie uporządkowane 
indexterm:[Krzyżowanie, Ordered]
indexterm:[Krzyżowanie, OX1]
Krzyżowanie uporządkowane jest w szczególności przydatne, gdy mamy do czynienia z chromosomami, których geny mogą pochodzić tylko ze ściśle określonej puli footnote:[https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_crossover.htm]. 

#TODO Dodać przykład!#

[source,csharp]
.Implementacja OrderedCrossover
----
public class OrderedCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
{
    private static readonly Random _random = new();
    public double Begining { get; }
    public double End { get; }

    private readonly IGenableChromosomeFactory<T, E> _factory;

    public int RequiredNumberOfParents { get; } = 2;

    public IEnumerable<T> MakeChildren(IEnumerable<T> parentsRaw)
    {
        var parents = parentsRaw.ToList();
        if (parents.Count != RequiredNumberOfParents)
            throw new ArgumentException("The number of parents isn't sufficient", nameof(parentsRaw));
        if (parents[0].Genes.Count != parents[1].Genes.Count)
            throw new ArgumentException("Different size of genes is not supported here!");

        var maxCount = parents[0].Genes.Count;


        var begining = (int) (maxCount * Math.Min(Begining, End)); <1>
        var end = (int) (maxCount * Math.Max(Begining, End));

        var child1PrimeGenes = parents[0].Genes.Skip(begining).Take(end - begining).ToList(); <2>
        var child2PrimeGenes = parents[1].Genes.Skip(begining).Take(end - begining).ToList();

        var parent1FilteredGens = parents[0].Genes.Where(d => !child2PrimeGenes.Contains(d)).ToList(); <3>
        var parent2FilteredGens = parents[1].Genes.Where(d => !child1PrimeGenes.Contains(d)).ToList();

        var child1Genes = <4>
            parent2FilteredGens.Take(begining)
                                .Concat(child1PrimeGenes)
                                .Concat(parent2FilteredGens.Skip(begining)
                                                            .Take(maxCount - (begining + child1PrimeGenes.Count)));

        var child2Genes =
            parent1FilteredGens.Take(begining)
                                .Concat(child2PrimeGenes)
                                .Concat(parent1FilteredGens.Skip(begining)
                                                            .Take(maxCount - (begining + child2PrimeGenes.Count)));

        yield return _factory.FromGenes(child1Genes.ToList());
        yield return _factory.FromGenes(child2Genes.ToList());
    }
}
----

<1> Na początku określamy miejsca zwrotne, w których będziemy zmieniać źródło genów. 
Zmienne `Begining` i `End` (proszę zwrócić uwagę na wielkie litery) określają procentowo miejsce zwrotne. 
Miejsce określone bezwzględnie przechowywane jest w zmiennych o tych samych nazwach, lecz z małych liter.
<2> W tym miejscu pobierane są geny z rodziców, które zostaną u potomków,
<3> W tym miejscu ze względu optymalizacyjnych są określane geny, które nie zostały jeszcze wykorzystane w kroku <2>.
<4> W tym miejscu dochodzi do połączenia genów jednego rodzica (z kroku <2>) z pozostałymi genami rodzica drugiego (z kroku <3>).

=== Cyclic Ordered Chrossover
#TODO: Znaleźć bibliografię#
Uporządkowane krzyżowanie cykliczne jest oparte o wybrany (lub losowy) okres, który działa według następującego sposobu:

. Podziel chromosom pierwszego rodzica na kawałki o wybranej długości (okres),
. Odrzuć co drugi kawałek,
. W puste miejsca wstaw pozostałe geny drugiego rodzica.
. Wykonaj to samo dla drugiego rodzica. 

indexterm:[Krzyżowanie, uniform]
Działanie to przypomina krzyżowanie jednolite (uniform crossover) z tą różnicą, że zapewnione jest, że wszystkie geny, które występują u obojga rodziców, wystąpią również u potomków.

#TODO: Dodać ilustrację#

[source,csharp]
.Implementacja CyclicOrderedCrossover
----
public class CyclicOrderedCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
{
    private static readonly Random _random = new();
    public int? Length { get; }
    private readonly IGenableChromosomeFactory<T, E> _factory;

    public int RequiredNumberOfParents { get; } = 2;

    public IEnumerable<T> MakeChildren(IEnumerable<T> parentsRaw)
    {
        var parents = parentsRaw.ToList();
        if (parents.Count != RequiredNumberOfParents)
            throw new ArgumentException("The number of parents isn't sufficient", nameof(parentsRaw));
        if (parents[0].Genes.Count != parents[1].Genes.Count)
            throw new ArgumentException("Different size of genes is not supported here!");

        var maxCount = parents[0].Genes.Count;
        var cycleLength = Length ?? _random.Next(maxCount);

        if (cycleLength >= maxCount)
            throw new InvalidOperationException("Length of cycle is lower than length of chromosome!");

        int i = 0;

        {
            i = 0;
            var child1Prime = parents[0].Genes.GroupBy(_ => i++ / cycleLength).Where(d => d.Key % 2 == 0).ToList();
            i = 0;
            var child1Supplement = parents[1].Genes.Where(d => !child1Prime.Any(e => e.Contains(d)))
                                             .GroupBy(_ => i++ / cycleLength).ToList();
            var readyKid1 = new List<E>();
            i = 0;
            foreach (var kidPart in child1Prime)
            {
                readyKid1.AddRange(kidPart);
                if (i >= child1Supplement.Count) break;
                readyKid1.AddRange(child1Supplement.ElementAt(i++));
            }

            yield return _factory.FromGenes(readyKid1);
        }
        {
            i = 0;
            var child2Prime = parents[1].Genes.GroupBy(_ => i++ / cycleLength).Where(d => d.Key % 2 == 0).ToList();


            i = 0;
            var child2Supplement = parents[1].Genes.Where(d => !child2Prime.Any(e => e.Contains(d)))
                                             .GroupBy(_ => i++ / cycleLength).ToList();
            var readyKid2 = new List<E>();
            i = 0;
            foreach (var kidPart in child2Prime)
            {
                readyKid2.AddRange(kidPart);
                if (i >= child2Supplement.Count) break;
                readyKid2.AddRange(child2Supplement.ElementAt(i++));
            }

            yield return _factory.FromGenes(readyKid2);
        }
    }
}
----

=== Jedno- i wielo- punktowe krzyżowanie
indexterm:[Krzyżowanie, singlepoint]
indexterm:[Krzyżowanie, multipoint]
Krzyżowania te opierają się na tym, że budowanie chromosomu dziecka następuje raz z genów rodzica pierwszego, a raz z rodzica drugiego.
I tak w przypadku krzyżowania jedno punktowego wybieramy jedno miejsce (lub losujemy), a w przypadku krzyżowania wielopunktowego tych miejsc jest wiele footnote:[https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)].
Co ciekawe, krzyżowanie jednopunktowe można rozpatrywać jako szczególny przypadek krzyżowania wielopunktowego – tę możliwość wykorzystano również w implementacji. 
Dlatego też, poniższy kod reprezentuje tylko krzyżowanie wielopunktowe.

#TODO: Dodać ilustrację#

[source,csharp]
.Implementacja MultipointCrossover
----
public class MultiPointCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
{
    private readonly int _amountOfPoints;
    private readonly IGenableChromosomeFactory<T, E> _factory;
    private List<int> _splitPoints;
    public int RequiredNumberOfParents => 2;

    public IEnumerable<T> MakeChildren(IEnumerable<T> parents)
    {
        var list = parents.ToList();
        if (list.Count != RequiredNumberOfParents)
            throw new ArgumentException("The number of parents isn't sufficient", nameof(parents));
        if (list[0].Genes.Count != list[1].Genes.Count)
            throw new ArgumentException("Different size of genes is not supported here!");

        var maxCount = list[0].Genes.Count;
        var childGenes1 = new List<E>();
        var childGenes2 = new List<E>();
        var random = new Random();

        if (_splitPoints == null || _splitPoints.Count == 0)
        {
            _splitPoints = new List<int>(_amountOfPoints);
            for (int j = 0; j < _amountOfPoints; ++j) _splitPoints.Add(random.Next(maxCount - 1));
            _splitPoints.Sort();
        }

        for (int i = 0; i < maxCount; ++i)
        {
            int next = _splitPoints.Count(d => d >= i) % 2;
            childGenes1.Add(next == 0 ? list[0].Genes[i] : list[1].Genes[i]);
            childGenes2.Add(next == 1 ? list[0].Genes[i] : list[1].Genes[i]);
        }

        yield return _factory.FromGenes(childGenes1);
        yield return _factory.FromGenes(childGenes2);
    }
}
----

=== Uniform Crossover
#TODO: Znaleźć bibliografię#
indexterm:[Krzyżowanie, Uniform]
Krzyżowanie jednorodne polega na równomiernym pobraniu materiału genetycznego od każdego z rodziców i jego równomierne rozłożenie.

#TODO: Dodać przykład#

[source,csharp]
.Implementacja UniformCrossover
----
public class UniformCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
    {
        private readonly IGenableChromosomeFactory<T, E> _factory;
        public int RequiredNumberOfParents => 2;

        public IEnumerable<T> MakeChildren(IEnumerable<T> parents)
        {
            var list = parents.Take(RequiredNumberOfParents).ToList();
            if (list.Count != RequiredNumberOfParents)
                throw new ArgumentException("The number of parents isn't sufficient", nameof(parents));
            if (list[0].Genes.Count != list[1].Genes.Count)
                throw new ArgumentException("Different size of genes is not supported here!");

            var maxCount = list[0].Genes.Count;
            var childGenes1 = new List<E>();
            var childGenes2 = new List<E>();
            var random = new Random();
            for (int i = 0; i < maxCount; ++i)
            {
                int next = random.Next(1); <1>
                childGenes1.Add(next == 0 ? list[0].Genes[i] : list[1].Genes[i]);
                childGenes2.Add(next == 1 ? list[0].Genes[i] : list[1].Genes[i]);
            }

            yield return _factory.FromGenes(childGenes1);
            yield return _factory.FromGenes(childGenes2);
        }
    }
----

<1> W tym miejscu dokonujemy decyzji, za pomocą losowania, czy dany gen ma pochodzić od rodzica pierwszego, czy od rodzica drugiego.

== Mutacje
Mutacja to jeden z głownych elementów ewolucji - pozwala na wprowadzenie kompletnie nowych elementów do już istniejącej populacji.
W przypadków algorytmów genetycznych ważnym jest, aby prawdopobieństwo wystąpienia mutacji było niskie <<FalcoCioppa2002>>.

=== Mutacja losowego resetu
indexterm:[Mutacja, Random Resseting]
Mutacja ta najlepiej działa w przypadku, kiedy poszczególne geny składają się z liczb. 
Jej działanie polega na losowym wybraniu genu, który zostanie wylosowany ponownie.

#TODO: Dodać ilustrację przykłądu#

[source,csharp]
.Implementacja RandomRessetingMutation
----
public class RandomResettingMutation<T, E> : BaseMutation<T> where T : IGenableChromosome<E>
{
    private readonly IGenableChromosomeFactory<T, E> _factory;
    public double MutationThreshold { get; set; } = 0.1;

    public T? Mutate(T offspring) <1>
    {
        Random rnd = new();
        var shouldMutate = rnd.NextDouble() < MutationThreshold;
        if (shouldMutate) return MutateImplementation(offspring);
        return default(T?);
    }

    protected override T MutateImplementation(T offspring) <2>
    {
        Random rnd = new();
        var genes = offspring.Genes.ToList();
        var geneToMutate = rnd.Next(genes.Count);
        genes[geneToMutate] = _factory.GetGene(geneToMutate);
        return _factory.FromGenes(genes);
    }
}
----

<1> Najpierw należy zdecydować, czy mutacja powinna wogóle wystąpić: losowana jest wartość od 0 do 1.0 a następnie sprawdzana, czy jest mniejsza od wartości progowej.
<2> Jeśli mutacja występuje to wylosuj miejsce mutacji a następnie zastąp to nowym genem.

=== Mutacja przestawna
indexterm:[Mutacja, Swap] indexterm:[Mutacja, Translocation]
Mutacja ta polega na zamianie miejscami losowo wybranych neuronów.
Najlepiej sprawdza się w przypadku problemów o skończonym i jasno określonym zestawie genów, jak na przykład przy problemie plecakowym <<FalcoCioppa2002>>. 

#TODO: Dodać ilustrację przykładu#

[source,csharp]
----
public class SwapMutation<T, E> : BaseMutation<T> where T : IGenableChromosome<E>
{
    private readonly IGenableChromosomeFactory<T, E> _factory;
    public int AmountOfSwaps { get; set; } = 1;
    public double MutationThreshold { get; set; } = 0.1;

    public T? Mutate(T offspring) <1>
    {
        Random rnd = new();
        var shouldMutate = rnd.NextDouble() < MutationThreshold;
        if (shouldMutate) return MutateImplementation(offspring);
        return default(T?);
    }

    protected override T MutateImplementation(T offspring) <2>
    {
        var genes = offspring.Genes.ToList();
        var random = new Random();

        for (int i = 0; i < AmountOfSwaps; ++i)
        {
            var one = random.Next(genes.Count);
            var two = random.Next(genes.Count);
            var tmp = genes[one];
            genes[one] = genes[two];
            genes[two] = tmp;
        }

        return _factory.FromGenes(genes);
    }
}
----

<1> Najpierw należy zdecydować, czy mutacja powinna wogóle wystąpić: losowana jest wartość od 0 do 1.0 a następnie sprawdzana, czy jest mniejsza od wartości progowej.
<2> Jeśli mutacja występuje to wylosuj dwa miejsca mutacji i następnie zamień wybrane geny.

== Zakończenie działania Algorytmu Genetycznego
Każdy algorytm kiedyś musi się skończyć. 
W przypadku AG nie jest to takie oczywiste, ponieważ zazwyczaj rozwiązujemy problemy, które nie mają znanego nam, obiektywnego, miejsca zakończenia.
W związku z tym używa się kilku warunków zakończenia. 

#TODO: Znaleźć bibliografię#

=== Limit wszystkich generacji
Zakończenie to musi mieć jasno określoną ilość generacji, które wystąpią w trakcie działania całego algorytmu.
Niewątpliwą zaletą takiej zasady jest względnie łatwy do przewidzenia czas oczekiwania na rezultat.

#TODO: Znaleźć bibliografię#

[source,csharp]
.Implementacja MaxGenerationCountImplementation
----
public class GenerationNumberTermination : ITermination
{
    public int MaxGenerationsCount { get; }

    public bool HasReached(IGeneticAlgorithm geneticAlgorithm)
    {
        return geneticAlgorithm.GenerationsNumber > MaxGenerationsCount;
    }
}
----

=== Limit zwycięstw pojedynczego neuronu
Zasada ta polega na tym, że działanie algorytmu zostaje zakończone po przekroczeniu ściśle określonej liczby zwycięstw jednego neuronu. 
W tym przypadku niemożliwe może być określenie z góry ile czasu zajmie wyliczenie, w zamian daje pewne zabezpieczenie przed niekorzystnym wylosowaniem populacji początkowej.

#TODO: Znaleźć bibliografię#

[source,csharp]
----
public class TheSameNeuronWinner : ITermination
{
    [JsonIgnore] public long AmountLastNeruonWins { get; private set; } = 0;
    private IChromosome _lastKnwonWinner = null;
    public long MaxGenerationsCount { get; }

    public bool HasReached(IGeneticAlgorithm geneticAlgorithm)
    {
        if (_lastKnwonWinner != geneticAlgorithm.BestChromosome)
        {
            AmountLastNeruonWins = 0;
            _lastKnwonWinner = geneticAlgorithm.BestChromosome;
        }

        return MaxGenerationsCount < ++AmountLastNeruonWins;
    }
----

== Algorytm optymalizacji rojem cząstek (PSO)
#TODO: TBD#

= Problemy dla algorytmów genetycznych
#TODO: TBD#

== Problem plecakowy
#TODO: TBD#

== Problem komiwojażera
#TODO: TBD#

== Optymalizacja funkcji
#TODO: TBD#

== Wnioski
#TODO: TBD#

[bibliography]
= Bibliografia

* [[[Kumar2010]]] Kumar, Manoj, Mohamed Husain, Naveen Upreti, i Deepti Gupta. 2010. „Genetic Algorithm: Review and Application”. SSRN Electronic Journal. https://doi.org/10.2139/ssrn.3529843.
* [[FalcoCioppa2002]] De Falco, I, A Della Cioppa, i E Tarantino. 2002. „Mutation-Based Genetic Algorithm: Performance Evaluation”. Applied Soft Computing 1 (4): 285–99. https://doi.org/10.1016/S1568-4946(02)00021-2.

[index]
= Indeks