= Algorytmy Genetyczne
Mikołaj Dalecki <mikdal002@utp.edu.pl>; Mateusz Lewandowski <matlew13@utp.edu.pl>; Karol Appel <karapp002@utp.edu.pl>; Przemysław Nadobny <prznad005@utp.edu.pl>; Jacek Suty <jacsut000@utp.edu.pl>
:toc:
:imagesdir: ./img
:sectnums:
:iconsdir: ./icons
:sectanchors:
:source-highlighter: pygments
:keywords: asciidoc, wstęp
:doctype: book

[.lead]
Niniejsze sprawozdanie jest rezultatem prac nad algorytmami genetycznymi i ich wykorzystaniem w znajdowaniu rozwiązania problemu komiwojażera/plecakowego i optymalizacji funkcji w porównaniu z algorytmem optymalizacji rojem cząstek (PSO). 

= Wstęp
((Algorytm genetyczny)) (dalej w pracy w skrócie AG) znajduje się w grupie algorytmów ewolucyjnych i jest powszechnie używany do problemów optymalizacyjnych, takich jak znajdowanie najkrótszej drogi, bądź modelowania systemów, gdzie zmienność odgrywa znaczącą rolę (np. giełda).
Jest on wyszukiwaniem heurystycznym zainspirowany zmianami genetycznymi w populacji i został przedstawiony przez ((Johna Holland))a na początku lat 70 XX wieku. 
Algorytm ten oparty jest o takie zagadnienia, jak: dziedziczenie, mutacje, selekcje i krzyżowania, które będą opisane w dalszej części pracy <<Kumar2010>>.

Uproszczony schemat działania algorytmu genetycznego przedstawiono na diagramie poniżej.
Pokrótce mówi on nam, aby <<Kumar2010>>:

. Zdefiniować nową populację poprzez wylosowanie całkowicie nowych osobników (przy rozpoczęciu algorytmu) bądź poprzez dokonanie wyboru rodziców, krzyżowania i mutacji.
. Następnie obliczyć dopasowanie każdego chromosomu.
. Na końcu sprawdzić, czy warunek zakończenia działania programu jest spełniony, jeśli nie, to powtórzyć. 

Wszystkie wymienione elementy zostaną szerzej opisane w następnych rozdziałach i sekcjach.

[plantuml, zasada-dzialania-ag, png]
.Sposób działania Algorytmu Genetycznego
....
start
repeat
    if (Czy to pierwsza generacja?) then (tak)
        :Wygeneruj zestaw losowych chromosomów;
    else (nie)
        :Wybierz rodziców;
        :Dokonaj krzyżowania;
        :Dokonaj ewentualnej mutacji;
    endif
    :Oblicz dopasowanie każdego chromosomu;
    
repeat while (Czy należy zakończyć algorytm?)
end
....


== Chromosomy
Każdy z chromosomów reprezentuje jedno możliwe rozwiązanie, a każdy z chromosomów składa się z ((allel))i (czasem zwanymi genami), które stanowią drobną część (na przykład bit, znak lub liczbę) będącą częścią tegoż rozwiązania  <<Kumar2010>>.

#TODO: TBD#

=== `GeneableChromosome` – implementacja
W naszym rozwiązaniu chromosom może implementować interfejs `IChromosome`, który przechowuje jedynie wartość dopasowania (`Fitness`). 
Jednak w celu uproszczenia implementacji, postępując zgodnie z zasadą DRY (z ang. _don't repeat yourself_ – nie powtarzaj siebie) wprowadzono interfejs `IGeneableChromosome`, który pozwala na dekompozycję każdego rozwiązania na drobne kawałki. 
Definicja tychże interfejsów prezentuje się następująco: 

#TODO: Dodać ilustrację chromosomu z różnymi genami#

[source,csharp]
.Interfejsy dla ((chromosom))ów
----
public interface IChromosome : IComparable
{
    double? Fitness { get; set; }
}
public interface IGenableChromosome<T> : IChromosome
{
    public IReadOnlyList<T> Genes { get; }
}
----
#TODO: TBD#

=== Funkcja dopasowania
Funkcja dopasowania jest inna dla każdego problemu i służy do oceny danego rozwiązania (chromosomu) footnote:[https://en.wikipedia.org/wiki/Fitness_function].
Najczęściej spotykanym traktowania dopasowania jest „im większe, tym lepsze”, aczkolwiek w naszym rozwiązaniu możliwe jest odwrócenie tej zasady, co pozwala na naturalne pisanie funkcji optymalizacyjnych.
Z takiej możliwości korzysta rozwiązanie problemu ((komiwojażer))a, gdzie wartość dopasowania jest równa długości ścieżki, jaką musi przebyć, a ta jest tym lepsza, im jest krótsza. 

Przykłady implementacji funkcji dopasowania zostaną przedstawione w następnych rozdziałach przy okazji omówienia poszczególnych problemów.

== Selekcja rodziców i populacja
W każdej następnej generacji dochodzi do selekcji rodziców w celu zrobienia potomków, którzy będą stanowili nową generację.
Rozmiar generacji zależy od natury problemu i zazwyczaj mieści się w zakresie od kilkuset do kilku tysięcy osobników.

Wybór rodziców zazwyczaj opiera się o poziom dopasowania do problemu: im lepszy, tym większe prawdopodobieństwo zostania dawcą genów  <<Kumar2010>>. 
#TODO: TBD#

=== Selekcja ruletkowa
indexterm:[Selekcja, Turniejowa]
Selekcja ruletkowa (oraz selekcja turniejowa – nieporuszana w niniejszej pracy) jest jedną z popularniejszych metod selekcji  <<Kumar2010>>. 
#TODO: TBD#

[source,csharp]
.Implementacja selekcji ruletkowej indexterm:[Selekcja, ruletkowa]
----
public class RouletteSelection
{
    private readonly Random _random = new();
    public bool? IsReversed { get; set; } = null;

    public IEnumerable<T> SelectChromosomes<T>(Generation<T> previousGeneration, int requiredNumberOfParents)
        where T : IChromosome
    {
        if (IsReversed == null) <1>
        {
            var min = previousGeneration.Min();
            var max = previousGeneration.Max();
            IsReversed = max.Fitness < min.Fitness;
        }

        var sumOfFitnesse = 0.0;

        foreach (var chrom in previousGeneration)
        {
            if (!chrom.Fitness.HasValue)
                throw new ArgumentException("Chromosome doesn't have fitness calculated!");

            sumOfFitnesse += chrom.Fitness.Value;
        }

        if (IsReversed == true) sumOfFitnesse = 1.0 / sumOfFitnesse;

        var parentThresholds = new List<double>(requiredNumberOfParents);

        for (int i = 0; i < requiredNumberOfParents; ++i)
            parentThresholds.Add(_random.NextDouble() * sumOfFitnesse);

        parentThresholds = parentThresholds.OrderBy(d => d).ToList(); <2>

        var minimumParentThreshold = parentThresholds[0];

        var selectionProgress = 0.0;
        foreach (var chrom in previousGeneration)
        {
            selectionProgress += IsReversed == true ? 1.0 / chrom.Fitness!.Value : chrom.Fitness!.Value; <3>
            if (minimumParentThreshold > selectionProgress) continue;

            parentThresholds.RemoveAt(0); <4>
            yield return chrom;

            if (parentThresholds.Count == 0) yield break;
            minimumParentThreshold = parentThresholds[0];
        }
    }
}
----

<1> Na początku należy sprawdzić, czy czasem chromosom nie ma odwróconego wartościowania (to znaczy, że lepsza odpowiedź to ta o mniejszej wartości).
<2> Następnie losujemy tyle progów ile rodziców potrzeba (domyślnie 2) wyrażonych w procentach.
<3> Na końcu w bierzemy kolejne chromosomy i dodajemy ich wartości do siebie. W momencie, w którym suma przekroczy procentową wartość progu, aktywny chromosom zostaje wybrany na rodzica.
<4> Algorytm jest powtarzany, aż wszystkie progi zostaną przekroczone.

== Krzyżowanie
Krzyżowanie, czasem zwane również ((rekomobinowanie))m, to proces łączenia genów rodziców w taki sposób, aby uzyskać nowego potomka, reprezentujące nowe rozwiązanie <<Kumar2010>>. 

=== Krzyżowanie uporządkowane 
indexterm:[Krzyżowanie, Ordered]
indexterm:[Krzyżowanie, OX1]
Krzyżowanie uporządkowane jest w szczególności przydatne, gdy mamy do czynienia z chromosomami, których geny mogą pochodzić tylko ze ściśle określonej puli footnote:[https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_crossover.htm]. 

#TODO Dodać przykład!#

[source,csharp]
.Implementacja OrderedCrossover
----
public class OrderedCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
{
    private static readonly Random _random = new();
    public double Begining { get; }
    public double End { get; }

    private readonly IGenableChromosomeFactory<T, E> _factory;

    public int RequiredNumberOfParents { get; } = 2;

    public IEnumerable<T> MakeChildren(IEnumerable<T> parentsRaw)
    {
        var parents = parentsRaw.ToList();
        if (parents.Count != RequiredNumberOfParents)
            throw new ArgumentException("The number of parents isn't sufficient", nameof(parentsRaw));
        if (parents[0].Genes.Count != parents[1].Genes.Count)
            throw new ArgumentException("Different size of genes is not supported here!");

        var maxCount = parents[0].Genes.Count;


        var begining = (int) (maxCount * Math.Min(Begining, End)); <1>
        var end = (int) (maxCount * Math.Max(Begining, End));

        var child1PrimeGenes = parents[0].Genes.Skip(begining).Take(end - begining).ToList(); <2>
        var child2PrimeGenes = parents[1].Genes.Skip(begining).Take(end - begining).ToList();

        var parent1FilteredGens = parents[0].Genes.Where(d => !child2PrimeGenes.Contains(d)).ToList(); <3>
        var parent2FilteredGens = parents[1].Genes.Where(d => !child1PrimeGenes.Contains(d)).ToList();

        var child1Genes = <4>
            parent2FilteredGens.Take(begining)
                                .Concat(child1PrimeGenes)
                                .Concat(parent2FilteredGens.Skip(begining)
                                                            .Take(maxCount - (begining + child1PrimeGenes.Count)));

        var child2Genes =
            parent1FilteredGens.Take(begining)
                                .Concat(child2PrimeGenes)
                                .Concat(parent1FilteredGens.Skip(begining)
                                                            .Take(maxCount - (begining + child2PrimeGenes.Count)));

        yield return _factory.FromGenes(child1Genes.ToList());
        yield return _factory.FromGenes(child2Genes.ToList());
    }
}
----

<1> Na początku określamy miejsca zwrotne, w których będziemy zmieniać źródło genów. 
Zmienne `Begining` i `End` (proszę zwrócić uwagę na wielkie litery) określają procentowo miejsce zwrotne. 
Miejsce określone bezwzględnie przechowywane jest w zmiennych o tych samych nazwach, lecz z małych liter.
<2> W tym miejscu pobierane są geny z rodziców, które zostaną u potomków,
<3> W tym miejscu ze względu optymalizacyjnych są określane geny, które nie zostały jeszcze wykorzystane w kroku <2>.
<4> W tym miejscu dochodzi do połączenia genów jednego rodzica (z kroku <2>) z pozostałymi genami rodzica drugiego (z kroku <3>).

=== Cyclic Ordered Chrossover
#TODO: Znaleźć bibliografię#
Uporządkowane krzyżowanie cykliczne jest oparte o wybrany (lub losowy) okres, który działa według następującego sposobu:

. Podziel chromosom pierwszego rodzica na kawałki o wybranej długości (okres),
. Odrzuć co drugi kawałek,
. W puste miejsca wstaw pozostałe geny drugiego rodzica.
. Wykonaj to samo dla drugiego rodzica. 

indexterm:[Krzyżowanie, uniform]
Działanie to przypomina krzyżowanie jednolite (uniform crossover) z tą różnicą, że zapewnione jest, że wszystkie geny, które występują u obojga rodziców, wystąpią również u potomków.

#TODO: Dodać ilustrację#

[source,csharp]
.Implementacja CyclicOrderedCrossover
----
public class CyclicOrderedCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
{
    private static readonly Random _random = new();
    public int? Length { get; }
    private readonly IGenableChromosomeFactory<T, E> _factory;

    public int RequiredNumberOfParents { get; } = 2;

    public IEnumerable<T> MakeChildren(IEnumerable<T> parentsRaw)
    {
        var parents = parentsRaw.ToList();
        if (parents.Count != RequiredNumberOfParents)
            throw new ArgumentException("The number of parents isn't sufficient", nameof(parentsRaw));
        if (parents[0].Genes.Count != parents[1].Genes.Count)
            throw new ArgumentException("Different size of genes is not supported here!");

        var maxCount = parents[0].Genes.Count;
        var cycleLength = Length ?? _random.Next(maxCount);

        if (cycleLength >= maxCount)
            throw new InvalidOperationException("Length of cycle is lower than length of chromosome!");

        int i = 0;

        {
            i = 0;
            var child1Prime = parents[0].Genes.GroupBy(_ => i++ / cycleLength).Where(d => d.Key % 2 == 0).ToList();
            i = 0;
            var child1Supplement = parents[1].Genes.Where(d => !child1Prime.Any(e => e.Contains(d)))
                                             .GroupBy(_ => i++ / cycleLength).ToList();
            var readyKid1 = new List<E>();
            i = 0;
            foreach (var kidPart in child1Prime)
            {
                readyKid1.AddRange(kidPart);
                if (i >= child1Supplement.Count) break;
                readyKid1.AddRange(child1Supplement.ElementAt(i++));
            }

            yield return _factory.FromGenes(readyKid1);
        }
        {
            i = 0;
            var child2Prime = parents[1].Genes.GroupBy(_ => i++ / cycleLength).Where(d => d.Key % 2 == 0).ToList();


            i = 0;
            var child2Supplement = parents[1].Genes.Where(d => !child2Prime.Any(e => e.Contains(d)))
                                             .GroupBy(_ => i++ / cycleLength).ToList();
            var readyKid2 = new List<E>();
            i = 0;
            foreach (var kidPart in child2Prime)
            {
                readyKid2.AddRange(kidPart);
                if (i >= child2Supplement.Count) break;
                readyKid2.AddRange(child2Supplement.ElementAt(i++));
            }

            yield return _factory.FromGenes(readyKid2);
        }
    }
}
----

=== Jedno- i wielo- punktowe krzyżowanie
indexterm:[Krzyżowanie, singlepoint]
indexterm:[Krzyżowanie, multipoint]
Krzyżowania te opierają się na tym, że budowanie chromosomu dziecka następuje raz z genów rodzica pierwszego, a raz z rodzica drugiego.
I tak w przypadku krzyżowania jedno punktowego wybieramy jedno miejsce (lub losujemy), a w przypadku krzyżowania wielopunktowego tych miejsc jest wiele footnote:[https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)].
Co ciekawe, krzyżowanie jednopunktowe można rozpatrywać jako szczególny przypadek krzyżowania wielopunktowego – tę możliwość wykorzystano również w implementacji. 
Dlatego też, poniższy kod reprezentuje tylko krzyżowanie wielopunktowe.

#TODO: Dodać ilustrację#

[source,csharp]
.Implementacja MultipointCrossover
----
public class MultiPointCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
{
    private readonly int _amountOfPoints;
    private readonly IGenableChromosomeFactory<T, E> _factory;
    private List<int> _splitPoints;
    public int RequiredNumberOfParents => 2;

    public IEnumerable<T> MakeChildren(IEnumerable<T> parents)
    {
        var list = parents.ToList();
        if (list.Count != RequiredNumberOfParents)
            throw new ArgumentException("The number of parents isn't sufficient", nameof(parents));
        if (list[0].Genes.Count != list[1].Genes.Count)
            throw new ArgumentException("Different size of genes is not supported here!");

        var maxCount = list[0].Genes.Count;
        var childGenes1 = new List<E>();
        var childGenes2 = new List<E>();
        var random = new Random();

        if (_splitPoints == null || _splitPoints.Count == 0)
        {
            _splitPoints = new List<int>(_amountOfPoints);
            for (int j = 0; j < _amountOfPoints; ++j) _splitPoints.Add(random.Next(maxCount - 1));
            _splitPoints.Sort();
        }

        for (int i = 0; i < maxCount; ++i)
        {
            int next = _splitPoints.Count(d => d >= i) % 2;
            childGenes1.Add(next == 0 ? list[0].Genes[i] : list[1].Genes[i]);
            childGenes2.Add(next == 1 ? list[0].Genes[i] : list[1].Genes[i]);
        }

        yield return _factory.FromGenes(childGenes1);
        yield return _factory.FromGenes(childGenes2);
    }
}
----

=== Uniform Crossover
#TODO: Znaleźć bibliografię#
indexterm:[Krzyżowanie, Uniform]
Krzyżowanie jednorodne polega na równomiernym pobraniu materiału genetycznego od każdego z rodziców i jego równomierne rozłożenie.

#TODO: Dodać przykład#

[source,csharp]
.Implementacja UniformCrossover
----
public class UniformCrossover<T, E> : ICrossover<T> where T : IGenableChromosome<E>
    {
        private readonly IGenableChromosomeFactory<T, E> _factory;
        public int RequiredNumberOfParents => 2;

        public IEnumerable<T> MakeChildren(IEnumerable<T> parents)
        {
            var list = parents.Take(RequiredNumberOfParents).ToList();
            if (list.Count != RequiredNumberOfParents)
                throw new ArgumentException("The number of parents isn't sufficient", nameof(parents));
            if (list[0].Genes.Count != list[1].Genes.Count)
                throw new ArgumentException("Different size of genes is not supported here!");

            var maxCount = list[0].Genes.Count;
            var childGenes1 = new List<E>();
            var childGenes2 = new List<E>();
            var random = new Random();
            for (int i = 0; i < maxCount; ++i)
            {
                int next = random.Next(1); <1>
                childGenes1.Add(next == 0 ? list[0].Genes[i] : list[1].Genes[i]);
                childGenes2.Add(next == 1 ? list[0].Genes[i] : list[1].Genes[i]);
            }

            yield return _factory.FromGenes(childGenes1);
            yield return _factory.FromGenes(childGenes2);
        }
    }
----

<1> W tym miejscu dokonujemy decyzji, za pomocą losowania, czy dany gen ma pochodzić od rodzica pierwszego, czy od rodzica drugiego.

== Mutacje
#TODO: TBD#

=== Random Resseting Mutation
#TODO: TBD#

=== Swap Mutation
#TODO: TBD#

== Zakończenie działania Algorytmu Genetycznego
#TODO: TBD#

=== `GenerationNumberTermination`
#TODO: TBD#

=== `TheSameNeuronWinner`
#TODO: TBD#

== Algorytm optymalizacji rojem cząstek (PSO)
#TODO: TBD#

= Problemy dla algorytmów genetycznych
#TODO: TBD#

== Problem plecakowy
#TODO: TBD#

== Problem komiwojażera
#TODO: TBD#

== Optymalizacja funkcji
#TODO: TBD#

== Wnioski
#TODO: TBD#

[bibliography]
= Bibliografia


* [[[Kumar2010]]] Kumar, Manoj, Mohamed Husain, Naveen Upreti, i Deepti Gupta. 2010. „Genetic Algorithm: Review and Application”. SSRN Electronic Journal. https://doi.org/10.2139/ssrn.3529843.

[index]
= Index