== Optymalizacja funkcji
#TODO: TBD#

.Ogólna implementacja

Całość optymalizacji funkcji jest oparta o zestaw klas bazowych, który pozwala na ułatwienie badań wybranych funkcji i innych.

[source,csharp]
.Implementacja frabryki bitowych chromosomów
----
public class BitChromosomeFactory : IGenableChromosomeFactory<SimpleChromosome, bool>
{
    private readonly int _length;
    private readonly Random _random;

    public BitChromosomeFactory(int length)
    {
        _length = length;
        _random = new Random();
    }

    public virtual SimpleChromosome CreateNew()
    {
        return new SimpleChromosome(Enumerable.Range(0, _length).Select(d => GetGene(d)).ToList());
    }

    public virtual SimpleChromosome FromGenes(IList<bool> genes)
    {
        if (genes.Count != _length) throw new Exception();
        return new SimpleChromosome(genes.ToList());
    }

    public virtual bool GetGene(int geneNumber)
    {
        return _random.Next() % 2 == 0;
    }
}
----

[source,csharp]
.Implementacja fabryki do produkcji chromosomów dla problemów ciągłych.
----
public class FloatChromosomeFactory : BitChromosomeFactory
{
    public int Length { get; }
    public float Max { get; set; } = 500;
    public float Min { get; set; } = -500;

    public FloatChromosomeFactory() : this(2) { }

    public FloatChromosomeFactory(int length) : base(length * 32)
    {
        Length = length;
    }

    public override SimpleChromosome CreateNew()
    {
        var random = new Random();
        List<float> gensDoubles = new List<float>();
        for (int i = 0; i < Length; ++i)
        {
            var value = random.NextDouble() * (Max - Min) + Min;
            gensDoubles.Add((float) value);
        }

        var bytes = gensDoubles.SelectMany(d => BitConverter.GetBytes(d)).ToArray();
        var bitArray = new BitArray(bytes);

        var retList = new List<bool>();
        foreach (var bit in bitArray)
        {
            var boolean = (bool) bit;
            retList.Add(boolean);
        }

        return base.FromGenes(retList);
    }

    public override SimpleChromosome FromGenes(IList<bool> genes)
    {
        if (genes.Count % 32 != 0) throw new Exception("Amount of bits must be divisible by 32!");

        for (int i = 0; i < genes.Count; i += 32)
        {
            var dbl = BitConverter.ToSingle(genes.Skip(i).Take(32).ToBytes());
            if (dbl < Min || dbl > Max) return CreateNew();
            if (double.IsNaN(dbl)) return CreateNew();
        }

        return base.FromGenes(genes);
    }
}
----

[source,csharp]
.Chromosom przechowujący informacje o bitach
----
public class SimpleChromosome : FitnessComparableChromosome, IGenableChromosome<bool>
{
    public SimpleChromosome(List<bool> genes)
    {
        Genes = genes;
    }

    public override int GetHashCode()
    {
        int hash = 1;
        foreach (var gen in Genes) hash = HashCode.Combine(hash, gen.GetHashCode());

        return hash;
    }

    public IReadOnlyList<bool> Genes { get; }

    public int CompareTo(object? obj)
    {
        return -base.CompareTo(obj);
    }
}
----

=== Funkcja McCormick'a
#TODO: TBD#

[source,csharp]
.Implementacja funkcji McCormick'a
----
/// <summary>
///     https://www.sfu.ca/~ssurjano/mccorm.html
/// </summary>
public class MCCORMICKChromosomeFitness : IFitness<SimpleChromosome>
{
    /// <inheritdoc />
    public double Evaluate(SimpleChromosome chromosome)
    {
        if (chromosome.Genes.Count != 64) throw new Exception();

        var val1 = BitConverter.ToSingle(chromosome.Genes.Take(32).ToBytes());
        var val2 = BitConverter.ToSingle(chromosome.Genes.Skip(32).Take(32).ToBytes());
        var result = Math.Sin(val1 + val2) + Math.Pow(val1 - val2, 2) - 1.5 * val1 + 2.5 * val2 + 1;
        if (double.IsNaN(result))
        {
            return double.PositiveInfinity;
        }

        return result;
    }
}
----

=== Funkcja Schwefela
#TODO: TBD#

[source,csharp]
.Implementacja funkcji Schwefela
----
/// <summary>
///     http://www.geatbx.com/ver_3_5/fcnfun7.html
/// </summary>
public class SchwefelChromosomeFitness : IFitness<SimpleChromosome>
{
    /// <inheritdoc />
    public double Evaluate(SimpleChromosome chromosome)
    {
        if (chromosome.Genes.Count != 64) throw new Exception();

        var values = new[]
        {
            BitConverter.ToSingle(chromosome.Genes.Take(32).ToBytes()),
            BitConverter.ToSingle(chromosome.Genes.Skip(32).ToBytes()),
        };

        double sum = 0;
        for (int i = 0; i < values.Length; i++) sum += -values[i] * Math.Sin(Math.Sqrt(Math.Abs(values[i])));
        var result = sum;
        if (double.IsNaN(result))
        {
            return double.PositiveInfinity;
        }

        return result;
    }
}
----