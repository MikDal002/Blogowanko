== Znajdowanie miniumum funkcji testowych
Testy optymalizacji poszczególnych funkcji przeprowadzono za pomocą funkcji testowych zwanych również sztucznymi przestrzeniami footnote:[https://en.wikipedia.org/wiki/Test_functions_for_optimization].
Funkcje te zostały zaprojektowanie przez badaczy w celu testowania takich cech algorytmów jak:

* precyzja,
* pewność,
* ogólna wydajność.


=== Ogólna implementacja

Mechanizm optymalizacji funkcji jest oparty o trzy klasy podstawowe, które pozwalają na proste dodawanie kolejnych funkcji do badań.
Na początek leci klasa bazowa dla fabryki: `BitChromosomeFactory`, która odpowiada za produkcje chromosomów pozwalających na pracę na pojedynczych bitach.

[source,csharp]
.Implementacja fabryki operującej na pojedynczych bitach
----
public class BitChromosomeFactory : IGenableChromosomeFactory<SimpleChromosome, bool>
{
    private readonly int _length;
    private readonly Random _random;

    public BitChromosomeFactory(int length)
    {
        _length = length;
        _random = new Random();
    }

    public virtual SimpleChromosome CreateNew()
    {
        return new SimpleChromosome(Enumerable.Range(0, _length).Select(d => GetGene(d)).ToList());
    }

    public virtual SimpleChromosome FromGenes(IList<bool> genes)
    {
        if (genes.Count != _length) throw new Exception();
        return new SimpleChromosome(genes.ToList());
    }

    public virtual bool GetGene(int geneNumber)
    {
        return _random.Next() % 2 == 0;
    }
}
----

Z fabryki `BitChromosomeFactory` dziedziczona jest klasa `FloatChromosomeFactory`, która opakowuje pojedyncze bity w zmienne zmiennoprzecinkowe pojedynczej precyzji. 
Jest to pewnego rodzaju fasada, która ukrywa przed programistą pojedyncze bity i dba o to, aby ich ilość zawsze była odpowiednia – czyli podzielna przez 32 footnote:[Dla niezaznajomionych, 32 bity są niezbędne aby reprezentować liczbę zmiennoprzecinkową pojedynczej precyzji]. 

[source,csharp]
.Implementacja fabryki do produkcji chromosomów dla problemów ciągłych.
----
public class FloatChromosomeFactory : BitChromosomeFactory
{
    public int Length { get; }
    public float Max { get; set; } = 500;
    public float Min { get; set; } = -500;

    public FloatChromosomeFactory() : this(2) { }

    public FloatChromosomeFactory(int length) : base(length * 32)
    {
        Length = length;
    }

    public override SimpleChromosome CreateNew()
    {
        var random = new Random();
        List<float> gensDoubles = new List<float>();
        for (int i = 0; i < Length; ++i)
        {
            var value = random.NextDouble() * (Max - Min) + Min;
            gensDoubles.Add((float) value);
        }

        var bytes = gensDoubles.SelectMany(d => BitConverter.GetBytes(d)).ToArray();
        var bitArray = new BitArray(bytes);

        var retList = new List<bool>();
        foreach (var bit in bitArray)
        {
            var boolean = (bool) bit;
            retList.Add(boolean);
        }

        return base.FromGenes(retList);
    }

    public override SimpleChromosome FromGenes(IList<bool> genes)
    {
        if (genes.Count % 32 != 0) throw new Exception("Amount of bits must be divisible by 32!");

        for (int i = 0; i < genes.Count; i += 32)
        {
            var dbl = BitConverter.ToSingle(genes.Skip(i).Take(32).ToBytes());
            if (dbl < Min || dbl > Max) return CreateNew();
            if (double.IsNaN(dbl)) return CreateNew();
        }

        return base.FromGenes(genes);
    }
}
----

Poniżej pokazany jest chromosom, który przechowuje informacje na temat rozwiązania w postaci ciągu bitów. 

[source,csharp]
.Chromosom przechowujący informacje o bitach
----
public class SimpleChromosome : FitnessComparableChromosome, IGenableChromosome<bool>
{
    public SimpleChromosome(List<bool> genes)
    {
        Genes = genes;
    }

    public override int GetHashCode()
    {
        int hash = 1;
        foreach (var gen in Genes) hash = HashCode.Combine(hash, gen.GetHashCode());

        return hash;
    }

    public IReadOnlyList<bool> Genes { get; }

    public int CompareTo(object? obj)
    {
        return -base.CompareTo(obj);
    }
}
----

=== Funkcja McCormick'a

.Wykres funkcji McCormick'a w zakresie od -2 do 4.
image::mccorm.png[]

[source,csharp]
.Implementacja funkcji McCormick'a
----
/// <summary>
///     https://www.sfu.ca/~ssurjano/mccorm.html
/// </summary>
public class MCCORMICKChromosomeFitness : IFitness<SimpleChromosome>
{
    /// <inheritdoc />
    public double Evaluate(SimpleChromosome chromosome)
    {
        if (chromosome.Genes.Count != 64) throw new Exception();

        var val1 = BitConverter.ToSingle(chromosome.Genes.Take(32).ToBytes());
        var val2 = BitConverter.ToSingle(chromosome.Genes.Skip(32).Take(32).ToBytes());
        var result = Math.Sin(val1 + val2) + Math.Pow(val1 - val2, 2) - 1.5 * val1 + 2.5 * val2 + 1;
        if (double.IsNaN(result))
        {
            return double.PositiveInfinity;
        }

        return result;
    }
}
----

=== Funkcja Schwefela 

Funkcję Schwefela zaobserwowano w dwóch wariantach. 

. latexmath:[$418,9829n - \sum_{i=1}^{n} x_i \sin{\sqrt{|x_i|}}$]
. latexmath:[$\sum_{i=1}^{n} x_i \sin{\sqrt{|x_i|}}$],
+
gdzie `n` – liczba wymiarów.

Wartość na początku pierwszego równiania jest w rzeczywistości podniesieniem wartości funkcji o minimum globalne w celu uniknięcia ujemnych wartości. 
W przypadku niniejszej pracy wykorzystano drugi wariant funkcji Schwefela.

.Wykres funkcji Schefela w zakresie od -500 do 500. Na ilustracji wszystkie wartości sa podeniesione o wartość minimum. 
image::schwef.png[footnote:[https://www.sfu.ca/~ssurjano/schwef.html]]

[source,csharp]
.Implementacja funkcji Schwefela
----
/// <summary>
///     http://www.geatbx.com/ver_3_5/fcnfun7.html
/// </summary>
public class SchwefelChromosomeFitness : IFitness<SimpleChromosome>
{
    /// <inheritdoc />
    public double Evaluate(SimpleChromosome chromosome)
    {
        if (chromosome.Genes.Count != 64) throw new Exception();

        var values = new[]
        {
            BitConverter.ToSingle(chromosome.Genes.Take(32).ToBytes()),
            BitConverter.ToSingle(chromosome.Genes.Skip(32).ToBytes()),
        };

        double sum = 0;
        for (int i = 0; i < values.Length; i++) sum += -values[i] * Math.Sin(Math.Sqrt(Math.Abs(values[i])));
        var result = sum;
        if (double.IsNaN(result))
        {
            return double.PositiveInfinity;
        }

        return result;
    }
}
----

=== Wynik działania algorytmu genetycznego

.Wyniki pracy algorytmu genetycznego dla funkcji Schwefela.
image::szchwefel_results.jpg[]

=== Wynik działania PSO
#TODO: TBA#